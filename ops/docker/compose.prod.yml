# =============================================================================
# Docker Compose - Production Configuration
# =============================================================================
# 
# This file defines the production deployment architecture for the Team 
# Evaluatie App on a single VPS.
#
# Services:
# - db: PostgreSQL database
# - redis: Redis for job queue and caching
# - backend: FastAPI application
# - worker: RQ worker for async jobs
# - frontend: Next.js application
# - nginx: Reverse proxy with SSL termination
#
# Prerequisites:
# - Copy .env.prod.example to .env.prod and fill in all values
# - Ensure domain DNS points to this server
# - Run Certbot to obtain SSL certificates (see docs/PRODUCTION_DEPLOYMENT.md)
#
# Usage:
#   docker compose -f ops/docker/compose.prod.yml up -d
#   docker compose -f ops/docker/compose.prod.yml logs -f
#   docker compose -f ops/docker/compose.prod.yml down
#
# =============================================================================

networks:
  public:
    driver: bridge
    internal: false
  private:
    driver: bridge
    internal: true

volumes:
  postgres-data:
    driver: local
  redis-data:
    driver: local
  certbot-certs:
    driver: local
  certbot-www:
    driver: local
  nginx-logs:
    driver: local

services:
  # ===========================================================================
  # PostgreSQL Database
  # ===========================================================================
  db:
    image: postgres:16-alpine
    container_name: tea_db
    restart: unless-stopped
    
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-tea}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      POSTGRES_DB: ${POSTGRES_DB:-tea_production}
      # PostgreSQL performance tuning
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=en_US.UTF-8"
    
    volumes:
      - postgres-data:/var/lib/postgresql/data
      # Backup directory (mount host directory for backups)
      - ${BACKUP_DIR:-./backups}:/backups
    
    networks:
      - private
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-tea} -d ${POSTGRES_DB:-tea_production}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    
    # Security: Don't expose port to host in production
    # Only accessible within Docker network
    # ports:
    #   - "5432:5432"
    
    # Security hardening
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - FOWNER
      - SETGID
      - SETUID
    
    # Resource limits
    mem_limit: 2g
    mem_reservation: 512m
    cpus: "1.5"
    pids_limit: 512
    
    ulimits:
      nofile:
        soft: 1024
        hard: 2048

  # ===========================================================================
  # Redis (Job Queue & Caching)
  # ===========================================================================
  redis:
    image: redis:7-alpine
    container_name: tea_redis
    user: "999:999"
    restart: unless-stopped
    
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --requirepass ${REDIS_PASSWORD:?REDIS_PASSWORD is required}
    
    volumes:
      - redis-data:/data
    
    networks:
      - private
    
    healthcheck:
      test: ["CMD-SHELL", "redis-cli -a \"$REDIS_PASSWORD\" --raw PING | grep -q PONG"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s
    
    # Security: Don't expose port to host
    # ports:
    #   - "6379:6379"
    
    # Security hardening
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    
    # Resource limits
    mem_limit: 768m
    mem_reservation: 256m
    cpus: "0.5"
    pids_limit: 128
    
    ulimits:
      nofile:
        soft: 2048
        hard: 4096

  # ===========================================================================
  # FastAPI Backend
  # ===========================================================================
  backend:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    image: tea-backend:${IMAGE_TAG:-latest}
    container_name: tea_backend
    restart: unless-stopped
    
    env_file:
      - ../../.env.prod
    
    environment:
      # Override/ensure critical settings
      NODE_ENV: production
      APP_ENV: production
      # Database connection (use service name as host)
      DATABASE_URL: postgresql+psycopg2://${POSTGRES_USER:-tea}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-tea_production}
      # Redis connection (use service name as host)
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
    
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    
    networks:
      - private
      - public
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    
    # Internal port only (accessed via nginx)
    # ports:
    #   - "8000:8000"

    # Log configuration
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

    # Security hardening
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    tmpfs:
      - /tmp:rw,noexec,nosuid,size=100m
    
    # Resource limits
    mem_limit: 1g
    mem_reservation: 256m
    cpus: "1.0"
    pids_limit: 256
    
    ulimits:
      nofile:
        soft: 2048
        hard: 4096

  # ===========================================================================
  # RQ Worker (Async Job Processing)
  # ===========================================================================
  worker:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    image: tea-backend:${IMAGE_TAG:-latest}
    container_name: tea_worker
    restart: unless-stopped
    
    # Override CMD to run worker instead of API
    command: ["python", "worker.py"]
    
    env_file:
      - ../../.env.prod
    
    environment:
      NODE_ENV: production
      APP_ENV: production
      DATABASE_URL: postgresql+psycopg2://${POSTGRES_USER:-tea}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-tea_production}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
    
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      backend:
        condition: service_healthy
    
    networks:
      - private
    
    healthcheck:
      test: ["CMD-SHELL", "python -c \"import os,redis; redis.Redis.from_url(os.environ['REDIS_URL']).ping()\""]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    
    # Security hardening
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    
    # Resource limits
    mem_limit: 512m
    mem_reservation: 128m
    cpus: "0.5"
    pids_limit: 128
    
    ulimits:
      nofile:
        soft: 1024
        hard: 2048

  # ===========================================================================
  # Next.js Frontend
  # ===========================================================================
  frontend:
    build:
      context: ../../frontend
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
    image: tea-frontend:${IMAGE_TAG:-latest}
    container_name: tea_frontend
    restart: unless-stopped
    
    environment:
      NODE_ENV: production
      # API URL (internal network) - nginx will handle external routing
      NEXT_PUBLIC_API_URL: ${FRONTEND_URL}/api/v1
      PORT: "3000"
      HOSTNAME: "0.0.0.0"
    
    depends_on:
      backend:
        condition: service_healthy
    
    networks:
      - public
    
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:3000/ >/dev/null 2>&1 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 10
      start_period: 60s
    
    # Internal port only (accessed via nginx)
    # ports:
    #   - "3000:3000"
    
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

    # Security hardening for RCE mitigation
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE  # Only for binding to port 3000
    read_only: true
    tmpfs:
      - /tmp:rw,noexec,nosuid,nodev,noatime,size=100m
      - /app/.next/cache:rw,noexec,nosuid,nodev,noatime,size=50m
    
    # Resource limits optimized for Next.js SSR workload
    # Higher memory for React rendering and caching
    mem_limit: 1536m
    mem_reservation: 512m
    cpus: "0.75"
    pids_limit: 512  # Limited to prevent process spawning attacks
    
    ulimits:
      nofile:
        soft: 2048
        hard: 4096

  # ===========================================================================
  # Nginx Reverse Proxy
  # ===========================================================================
  nginx:
    image: nginx:stable-alpine
    container_name: tea_nginx
    restart: unless-stopped
    
    ports:
      - "80:80"
      - "443:443"
    
    volumes:
      # Nginx configuration
      - ../../ops/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ../../ops/nginx/ssl.conf:/etc/nginx/ssl.conf:ro
      - ../../ops/nginx/site.conf:/etc/nginx/conf.d/default.conf:ro
      # SSL certificates (managed by Certbot)
      - certbot-certs:/etc/letsencrypt:ro
      - certbot-www:/var/www/certbot:ro
      # Nginx logs (for fail2ban and monitoring)
      - nginx-logs:/var/log/nginx
      # Custom error pages (optional)
      # - ../../ops/nginx/html:/usr/share/nginx/html:ro
    
    depends_on:
      frontend:
        condition: service_healthy
      backend:
        condition: service_healthy
    
    networks:
      - public
    
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
    
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
    
    # Security hardening
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
      - CHOWN
      - SETGID
      - SETUID

  # ===========================================================================
  # Certbot (SSL Certificate Management)
  # ===========================================================================
  # Run once to obtain certificates, then use cron for renewal
  # Usage: docker compose -f compose.prod.yml run --rm certbot certonly --webroot ...
  certbot:
    image: certbot/certbot:latest
    container_name: tea_certbot
    
    volumes:
      - certbot-certs:/etc/letsencrypt
      - certbot-www:/var/www/certbot
    
    # Don't start automatically (run manually)
    entrypoint: ""
    command: /bin/sh -c "trap exit TERM; while :; do certbot renew --webroot -w /var/www/certbot; sleep 12h & wait $${!}; done"
    
    # Uncomment for auto-renewal daemon
    # restart: unless-stopped
    
    networks:
      - public
